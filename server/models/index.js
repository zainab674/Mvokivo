import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
    id: { type: String, required: true, unique: true }, // Auth user ID (now generated by us)
    email: { type: String, required: true },
    password: { type: String }, // Hashed password
    slug_name: String,
    tenant: String,
    role: { type: String, default: 'user' },
    plan: String,
    website_name: String,
    logo: String,
    custom_domain: String,
    contact_email: String,
    meta_description: String,
    live_demo_agent_id: String,
    live_demo_phone_number: String,
    policy_text: String,
    daily_summary: { type: Boolean, default: false },
    call_summary: { type: Boolean, default: false },
    summary_email: String,
    stripe_publishable_key: String,
    stripe_secret_key: String,
    stripe_enabled: { type: Boolean, default: false },
    created_at: { type: Date, default: Date.now },
    minutes_limit: { type: Number, default: 0 },
    minutes_used: { type: Number, default: 0 },
    is_active: { type: Boolean, default: true },
    name: String,
    contact: { type: mongoose.Schema.Types.Mixed } // For legacy compatibility
});

export const User = mongoose.model('User', userSchema);

const verificationTokenSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    token: { type: String, required: true },
    expires_at: { type: Date, required: true }
});

export const VerificationToken = mongoose.model('VerificationToken', verificationTokenSchema);

const verificationOtpSchema = new mongoose.Schema({
    user_email: { type: String, required: true },
    otp: { type: String, required: true },
    expires_at: { type: Date, required: true },
    created_at: { type: Date, default: Date.now }
});

export const VerificationOtp = mongoose.model('VerificationOtp', verificationOtpSchema);

const passwordResetTokenSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    token: { type: String, required: true },
    expires_at: { type: Date, required: true }
});

export const PasswordResetToken = mongoose.model('PasswordResetToken', passwordResetTokenSchema);

const planConfigSchema = new mongoose.Schema({
    plan_key: { type: String, required: true },
    name: { type: String, required: true },
    price: { type: Number, required: true },
    minutes: { type: Number }, // Included minutes per month (0 or null = unlimited)
    pay_as_you_go: { type: Boolean, default: false }, // If true, user must buy minutes separately
    features: { type: [String], default: [] },
    whitelabel_enabled: { type: Boolean, default: false },
    variant_id: String, // Lemon Squeezy Variant ID
    tenant: String, // Can be null for global plans
    display_order: { type: Number, default: 0 },
    is_active: { type: Boolean, default: true }
});

export const PlanConfig = mongoose.model('PlanConfig', planConfigSchema);

const campaignCallSchema = new mongoose.Schema({
    campaign_id: { type: String, required: true },
    contact_id: String,
    phone_number: { type: String, required: true },
    contact_name: String,
    email: String,
    status: { type: String, enum: ['pending', 'calling', 'completed', 'failed'], default: 'pending' },
    tenant: String,
    scheduled_at: Date,
    started_at: Date,
    completed_at: Date,
    notes: String,
    call_sid: String,
    room_name: String
}, { timestamps: { createdAt: 'created_at', updatedAt: 'updated_at' } });

export const CampaignCall = mongoose.model('CampaignCall', campaignCallSchema);

const callQueueSchema = new mongoose.Schema({
    campaign_id: { type: String, required: true },
    campaign_call_id: { type: String, required: true },
    phone_number: { type: String, required: true },
    scheduled_for: Date,
    status: { type: String, enum: ['queued', 'processing', 'completed', 'failed'], default: 'queued' },
    tenant: String,
    priority: { type: Number, default: 0 }
}, { timestamps: { createdAt: 'created_at', updatedAt: 'updated_at' } });

export const CallQueue = mongoose.model('CallQueue', callQueueSchema);

const phoneNumberSchema = new mongoose.Schema({
    id: { type: String, required: true, unique: true },
    user_id: String,
    phone_sid: String,
    number: { type: String, required: true, unique: true },
    label: String,
    inbound_assistant_id: String,
    trunk_sid: String,
    webhook_status: String,
    status: { type: String, default: 'active' },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const PhoneNumber = mongoose.model('PhoneNumber', phoneNumberSchema);

const smsMessageSchema = new mongoose.Schema({
    message_sid: { type: String, unique: true },
    to_number: String,
    from_number: String,
    body: String,
    direction: String, // 'inbound' or 'outbound'
    status: String,
    user_id: String,
    date_created: { type: Date, default: Date.now },
    date_updated: { type: Date, default: Date.now }
});

export const SmsMessage = mongoose.model('SmsMessage', smsMessageSchema);

const userTwilioCredentialSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    account_sid: String,
    auth_token: String,
    trunk_sid: String,
    domain_name: String,
    domain_prefix: String,
    credential_list_sid: String,
    sip_username: String,
    sip_password: String,
    label: String,
    is_active: { type: Boolean, default: true },
    created_at: { type: Date, default: Date.now }
});

export const UserTwilioCredential = mongoose.model('UserTwilioCredential', userTwilioCredentialSchema);

const userWhatsAppCredentialSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    whatsapp_number: { type: String, required: true },
    whatsapp_key: { type: String, required: true },
    label: String,
    is_active: { type: Boolean, default: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const UserWhatsAppCredential = mongoose.model('UserWhatsAppCredential', userWhatsAppCredentialSchema);

const userCalendarCredentialSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    provider: { type: String, required: true }, // 'calcom', etc.
    api_key: { type: String, required: true },
    event_type_id: String, // Optional legacy field
    event_type_slug: String, // Optional legacy field
    timezone: String,
    label: String,
    is_active: { type: Boolean, default: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const UserCalendarCredential = mongoose.model('UserCalendarCredential', userCalendarCredentialSchema);

const userEmailCredentialSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    provider: { type: String, enum: ['smtp', 'gmail', 'outlook'], default: 'smtp' },
    smtpHost: String,
    smtpPort: Number,
    smtpUser: String,
    smtpPass: String,
    imapHost: String,
    imapPort: Number,
    imapUser: String,
    imapPass: String,
    email: { type: String, required: true },
    isActive: { type: Boolean, default: true },
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const UserEmailCredential = mongoose.model('UserEmailCredential', userEmailCredentialSchema);

const calendarEventTypeSchema = new mongoose.Schema({
    calendar_credential_id: { type: String, required: true },
    event_type_id: String,
    event_type_slug: String,
    label: String,
    description: String,
    duration_minutes: Number,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const CalendarEventType = mongoose.model('CalendarEventType', calendarEventTypeSchema);

const assistantSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    name: { type: String, required: true },
    prompt: String,
    first_message: String,
    calendar: String,
    cal_api_key: String,
    cal_event_type_id: String,
    cal_event_type_slug: String,
    cal_timezone: String,
    cal_event_title: String,
    cal_event_length: Number,
    llm_provider_setting: String,
    llm_model_setting: String,
    temperature_setting: Number,
    max_token_setting: Number,
    voice_provider_setting: String,
    voice_model_setting: String,
    voice_name_setting: String,
    knowledge_base_id: String,
    n8n_webhook_url: String,
    n8n_auto_create_sheet: Boolean,
    n8n_drive_folder_id: String,
    n8n_spreadsheet_name_template: String,
    n8n_sheet_tab_template: String,
    n8n_spreadsheet_id: String,
    n8n_sheet_tab: String,
    n8n_save_name: Boolean,
    n8n_save_email: Boolean,
    n8n_save_phone: Boolean,
    n8n_save_summary: Boolean,
    n8n_save_sentiment: Boolean,
    n8n_save_labels: Boolean,
    n8n_save_recording_url: Boolean,
    n8n_save_transcript_url: Boolean,
    n8n_save_duration: Boolean,
    n8n_save_call_direction: Boolean,
    n8n_save_from_number: Boolean,
    n8n_save_to_number: Boolean,
    n8n_save_cost: Boolean,
    n8n_custom_fields: mongoose.Schema.Types.Mixed,
    groq_model: String,
    groq_temperature: Number,
    groq_max_tokens: Number,
    cerebras_model: String,
    cerebras_temperature: Number,
    cerebras_max_tokens: Number,
    structured_data_fields: mongoose.Schema.Types.Mixed,
    analysis_summary_prompt: String,
    analysis_evaluation_prompt: String,
    analysis_structured_data_prompt: String,
    analysis_structured_data_properties: mongoose.Schema.Types.Mixed,
    analysis_summary_timeout: Number,
    analysis_evaluation_timeout: Number,
    analysis_structured_data_timeout: Number,
    end_call_message: String,
    idle_messages: [String],
    max_idle_messages: Number,
    silence_timeout: Number,
    max_call_duration: Number,
    num_words_to_interrupt_assistant: Number,
    transfer_enabled: Boolean,
    transfer_phone_number: String,
    transfer_country_code: String,
    transfer_sentence: String,
    transfer_condition: String,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const Assistant = mongoose.model('Assistant', assistantSchema);

const callHistorySchema = new mongoose.Schema({
    call_id: { type: String, required: true, unique: true },
    assistant_id: { type: String, required: true },
    phone_number: String,
    call_duration: Number,
    call_status: String,
    transcription: mongoose.Schema.Types.Mixed,
    participant_identity: String,
    call_sid: String,
    recording_sid: String,
    recording_url: String,
    summary: String,
    sentiment: String,
    started_at: Date,
    ended_at: Date,
    created_at: { type: Date, default: Date.now }
});

export const CallHistory = mongoose.model('CallHistory', callHistorySchema);

const knowledgeBaseSchema = new mongoose.Schema({
    company_id: { type: String, required: true },
    name: { type: String, required: true },
    description: String,
    pinecone_index_name: String,
    pinecone_index_host: String,
    pinecone_index_status: String,
    pinecone_index_dimension: Number,
    pinecone_index_metric: String,
    pinecone_updated_at: Date,
    pinecone_created_at: Date,
    pinecone_assistant_id: String,
    pinecone_assistant_name: String,
    pinecone_assistant_instructions: String,
    pinecone_assistant_region: String,
    pinecone_assistant_updated_at: Date,
    pinecone_assistant_created_at: Date,
    created_at: { type: Date, default: Date.now }
});

export const KnowledgeBase = mongoose.model('KnowledgeBase', knowledgeBaseSchema);

const knowledgeDocumentSchema = new mongoose.Schema({
    doc_id: { type: String, required: true, unique: true },
    company_id: { type: String, required: true },
    knowledge_base_id: String,
    original_filename: String,
    file_size: Number,
    file_path: String,
    file_type: String,
    pinecone_file_id: String,
    pinecone_status: String,
    pinecone_processed_at: Date,
    upload_timestamp: Date,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const KnowledgeDocument = mongoose.model('KnowledgeDocument', knowledgeDocumentSchema);

const documentChunkSchema = new mongoose.Schema({
    doc_id: { type: String, required: true },
    chunk_index: Number,
    chunk_text: String,
    chunk_metadata: mongoose.Schema.Types.Mixed,
    embedding: [Number],
    pinecone_id: String,
    company_id: String,
    created_at: { type: Date, default: Date.now }
});

export const DocumentChunk = mongoose.model('DocumentChunk', documentChunkSchema);

const documentTextSchema = new mongoose.Schema({
    doc_id: { type: String, required: true, unique: true },
    extracted_text: String,
    created_at: { type: Date, default: Date.now }
});

export const DocumentText = mongoose.model('DocumentText', documentTextSchema);

const contactSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    name: String,
    email: String,
    phone: String,
    list_id: String, // Or use a separate List model and reference it
    tenant: String,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const Contact = mongoose.model('Contact', contactSchema);

const campaignSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    assistant_id: { type: String, required: true },
    name: { type: String, required: true },
    status: { type: String, default: 'draft' }, // status used in UI
    execution_status: { type: String, default: 'draft', enum: ['draft', 'running', 'paused', 'completed', 'error'] }, // status used by engine
    type: { type: String, default: 'outbound' },
    schedule: Date,
    next_call_at: Date,
    daily_cap: { type: Number, default: 100 },
    current_daily_calls: { type: Number, default: 0 },
    start_hour: { type: Number, default: 9 },
    end_hour: { type: Number, default: 17 },
    calling_days: { type: [String], default: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'] },
    campaign_prompt: String,
    contact_source: { type: String, enum: ['contact_list', 'csv_file'], default: 'contact_list' },
    contact_list_id: String,
    csv_file_id: String,
    total_calls_made: { type: Number, default: 0 },
    last_execution_at: Date,
    tenant: String,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const Campaign = mongoose.model('Campaign', campaignSchema);

const contactListSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    name: { type: String, required: true },
    tenant: String,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const ContactList = mongoose.model('ContactList', contactListSchema);

const csvFileSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    filename: String,
    original_filename: String,
    status: { type: String, default: 'pending' },
    row_count: { type: Number, default: 0 },
    headers: [String],
    file_path: String,
    tenant: String,
    created_at: { type: Date, default: Date.now }
});

export const CsvFile = mongoose.model('CsvFile', csvFileSchema);

const csvContactSchema = new mongoose.Schema({
    csv_file_id: { type: String, required: true },
    phone_number: String,
    first_name: String,
    last_name: String,
    email: String,
    do_not_call: { type: Boolean, default: false },
    metadata: mongoose.Schema.Types.Mixed,
    tenant: String,
    created_at: { type: Date, default: Date.now }
});

export const CsvContact = mongoose.model('CsvContact', csvContactSchema);

const emailCampaignSchema = new mongoose.Schema({
    userId: {
        type: String, // Changed to String to match MananUltratalk ID pattern
        required: true,
        index: true
    },
    name: {
        type: String,
        required: true
    },
    assistantId: {
        type: String,
        required: true
    },
    emailIntegrationId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'UserEmailCredential',
        required: true
    },
    contactSource: {
        type: String,
        enum: ['contact_list', 'csv_file'],
        required: true
    },
    contactListId: String,
    csvFileId: String,
    subject: {
        type: String,
        required: true
    },
    body: {
        type: String,
        required: true
    },
    attachmentPath: String,
    attachmentOriginalName: String,
    status: {
        type: String,
        enum: ['draft', 'sending', 'completed', 'failed', 'paused'],
        default: 'draft'
    },
    stats: {
        sent: { type: Number, default: 0 },
        delivered: { type: Number, default: 0 },
        failed: { type: Number, default: 0 },
        replies: { type: Number, default: 0 }
    },
    totalRecipients: { type: Number, default: 0 }
}, {
    timestamps: { createdAt: 'created_at', updatedAt: 'updated_at' }
});

export const EmailCampaign = mongoose.model('EmailCampaign', emailCampaignSchema);

const emailLogSchema = new mongoose.Schema({
    userId: {
        type: String,
        required: true,
        index: true
    },
    assistantId: String,
    campaignId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'EmailCampaign'
    },
    from: String,
    to: String,
    subject: String,
    body: String,
    direction: {
        type: String,
        enum: ['inbound', 'outbound'],
        required: true
    },
    status: {
        type: String,
        enum: ['sent', 'received', 'failed'],
        default: 'sent'
    },
    threadId: String,
    inReplyTo: String,
    hasAttachments: Boolean,
    messageId: String,
    error: String,
    created_at: {
        type: Date,
        default: Date.now
    }
});

export const EmailLog = mongoose.model('EmailLog', emailLogSchema);

const whitelabelSettingsSchema = new mongoose.Schema({
    domain: { type: String, unique: true, required: true },
    admin_email: { type: String, required: true },
    company_name: String,
    logo_url: String,
    favicon_url: String,
    primary_color: String,
    secondary_color: String,
    stripe_account_id: String,
    created_at: { type: Date, default: Date.now }
});

export const WhitelabelSettings = mongoose.model('WhitelabelSettings', whitelabelSettingsSchema);

const supportSessionSchema = new mongoose.Schema({
    admin_user_id: { type: String, required: true },
    target_user_id: { type: String, required: true },
    reason: String,
    duration_minutes: { type: Number, default: 30 },
    scoped_token: String,
    status: { type: String, default: 'active', enum: ['active', 'completed', 'revoked', 'expired'] },
    expires_at: { type: Date, required: true },
    ended_at: Date,
    created_at: { type: Date, default: Date.now }
});

export const SupportSession = mongoose.model('SupportSession', supportSessionSchema);

const auditLogSchema = new mongoose.Schema({
    session_id: String,
    admin_user_id: String,
    target_user_id: String,
    action_type: String,
    resource_type: String,
    resource_id: String,
    details: mongoose.Schema.Types.Mixed,
    ip_address: String,
    user_agent: String,
    created_at: { type: Date, default: Date.now }
});

export const AuditLog = mongoose.model('AuditLog', auditLogSchema);

const minutesPricingConfigSchema = new mongoose.Schema({
    tenant: { type: String, required: true, unique: true },
    price_per_minute: { type: Number, required: true },
    minimum_purchase: { type: Number, default: 0 },
    currency: { type: String, default: 'USD' },
    is_active: { type: Boolean, default: true },
    created_at: { type: Date, default: Date.now }
});

export const MinutesPricingConfig = mongoose.model('MinutesPricingConfig', minutesPricingConfigSchema);

const minutesPurchaseSchema = new mongoose.Schema({
    user_id: { type: String, required: true },
    minutes_purchased: { type: Number, required: true }, // Can be negative for debits (although code uses payment_method for tracking)
    amount_paid: Number,
    currency: String,
    payment_method: String, // 'stripe', 'whitelabel_admin', 'whitelabel_customer_sale'
    status: { type: String, default: 'pending' },
    notes: String,
    created_at: { type: Date, default: Date.now }
});

export const MinutesPurchase = mongoose.model('MinutesPurchase', minutesPurchaseSchema);

const paymentMethodSchema = new mongoose.Schema({
    id: { type: String, required: true }, // Stripe ID or similar
    user_id: { type: String, required: true },
    card_brand: String,
    card_last4: String,
    card_exp_month: Number,
    card_exp_year: Number,
    is_default: { type: Boolean, default: false },
    is_active: { type: Boolean, default: true },
    created_at: { type: Date, default: Date.now }
});

export const PaymentMethod = mongoose.model('PaymentMethod', paymentMethodSchema);

const invoiceSchema = new mongoose.Schema({
    id: { type: String, required: true },
    user_id: { type: String, required: true },
    amount: Number,
    currency: { type: String, default: 'USD' },
    status: String,
    invoice_number: String,
    period_start: Date,
    period_end: Date,
    customer_email: String,
    customer_name: String,
    created_at: { type: Date, default: Date.now }
});

export const Invoice = mongoose.model('Invoice', invoiceSchema);

const workspaceSettingsSchema = new mongoose.Schema({
    user_id: { type: String, required: true, unique: true },
    workspace_name: String,
    timezone: String,
    company_address: String,
    company_phone: String,
    company_website: String,
    company_industry: String,
    company_size: String,
    company_description: String,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const WorkspaceSettings = mongoose.model('WorkspaceSettings', workspaceSettingsSchema);

const workspaceMemberSchema = new mongoose.Schema({
    workspace_id: { type: String, required: true },
    user_id: String, // Can be null if pending
    email: { type: String, required: true },
    role: { type: String, default: 'member' }, // 'owner', 'admin', 'member'
    status: { type: String, default: 'active' }, // 'active', 'inactive'
    user_name: String,
    joined_at: { type: Date, default: Date.now },
    invited_at: Date
});

export const WorkspaceMember = mongoose.model('WorkspaceMember', workspaceMemberSchema);

const workspaceInvitationSchema = new mongoose.Schema({
    workspace_id: { type: String, required: true },
    email: { type: String, required: true },
    role: { type: String, default: 'member' },
    status: { type: String, default: 'pending' }, // 'pending', 'accepted', 'expired'
    token: { type: String, required: true, unique: true },
    invited_by: String,
    expires_at: { type: Date, required: true },
    created_at: { type: Date, default: Date.now }
});

export const WorkspaceInvitation = mongoose.model('WorkspaceInvitation', workspaceInvitationSchema);

const lemonSqueezyConfigSchema = new mongoose.Schema({
    tenant: { type: String, default: 'main' }, // 'main' or specific tenant
    api_key: String,
    store_id: String,
    webhook_secret: String,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now }
});

export const LemonSqueezyConfig = mongoose.model('LemonSqueezyConfig', lemonSqueezyConfigSchema);
